#pragma once

#include <juce_audio_basics/juce_audio_basics.h>
#include <cmath>

/**
 * Waveform types for the oscillator
 */
enum class OscillatorWaveform
{
    Sine = 0,
    Saw,
    Square,
    Triangle
};

/**
 * Band-limited oscillator using PolyBLEP (Polynomial Band-Limited Step) algorithm.
 *
 * PolyBLEP corrects discontinuities in waveforms (like saw and square) by applying
 * a polynomial correction near the transition points. This significantly reduces
 * aliasing compared to naive waveform generation.
 *
 * Reference: Välimäki & Huovilainen (2007)
 */
class PolyBLEPOscillator
{
public:
    PolyBLEPOscillator() = default;

    void prepare(double newSampleRate)
    {
        sampleRate = newSampleRate;
        phase = 0.0;
        phaseIncrement = 0.0;
    }

    void setFrequency(float newFrequency)
    {
        frequency = newFrequency;
        phaseIncrement = frequency / sampleRate;
    }

    void setWaveform(OscillatorWaveform newWaveform)
    {
        waveform = newWaveform;
    }

    float processSample()
    {
        float output = 0.0f;

        switch (waveform)
        {
            case OscillatorWaveform::Sine:
                output = generateSine();
                break;

            case OscillatorWaveform::Saw:
                output = generateSaw();
                break;

            case OscillatorWaveform::Square:
                output = generateSquare();
                break;

            case OscillatorWaveform::Triangle:
                output = generateTriangle();
                break;
        }

        // Advance phase
        phase += phaseIncrement;
        if (phase >= 1.0)
            phase -= 1.0;

        return output;
    }

    void reset()
    {
        phase = 0.0;
    }

    // Added getter for phase to support phase-locked rendering
    double getPhase() const { return phase; }

private:
    /**
     * PolyBLEP correction function.
     * Applies a polynomial correction near discontinuities to reduce aliasing.
     *
     * @param t The phase position relative to the discontinuity (0 to 1)
     * @param dt The phase increment (frequency / sampleRate)
     * @return The correction value to apply
     */
    float polyBLEP(double t, double dt) const
    {
        // t is the phase, dt is the phase increment

        // Near the start of the period (0)
        if (t < dt)
        {
            t /= dt;
            return static_cast<float>(t + t - t * t - 1.0);
        }
        // Near the end of the period (1)
        else if (t > 1.0 - dt)
        {
            t = (t - 1.0) / dt;
            return static_cast<float>(t * t + t + t + 1.0);
        }

        return 0.0f;
    }

    float generateSine() const
    {
        return std::sin(static_cast<float>(phase * juce::MathConstants<double>::twoPi));
    }

    float generateSaw()
    {
        // Naive sawtooth: goes from -1 to 1 over the period
        float naive = static_cast<float>(2.0 * phase - 1.0);

        // Apply PolyBLEP correction at the discontinuity (phase = 0/1)
        naive -= polyBLEP(phase, phaseIncrement);

        return naive;
    }

    float generateSquare()
    {
        // Naive square wave
        float naive = phase < 0.5 ? 1.0f : -1.0f;

        // Apply PolyBLEP at both discontinuities (0 and 0.5)
        naive += polyBLEP(phase, phaseIncrement);                    // Rising edge at 0
        naive -= polyBLEP(std::fmod(phase + 0.5, 1.0), phaseIncrement); // Falling edge at 0.5

        return naive;
    }

    float generateTriangle()
    {
        // Triangle can be generated by integrating a square wave
        // For PolyBLEP, we use a different approach:
        // Generate band-limited square and integrate it

        // Naive triangle
        float naive;
        if (phase < 0.5)
            naive = static_cast<float>(4.0 * phase - 1.0);
        else
            naive = static_cast<float>(3.0 - 4.0 * phase);

        // Triangle doesn't have discontinuities in value, only in derivative
        // PolyBLEP for triangle requires integrated PolyBLEP (PolyBLAMP)
        // For simplicity, we use the naive version which is already quite good
        // since triangle has no step discontinuities

        return naive;
    }

    double sampleRate = 44100.0;
    double phase = 0.0;
    double phaseIncrement = 0.0;
    float frequency = 440.0f;
    OscillatorWaveform waveform = OscillatorWaveform::Sine;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(PolyBLEPOscillator)
};
